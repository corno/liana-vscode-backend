"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.natural = exports.integer = void 0;
var integer;
(function (integer) {
    /**
     * Performs integer division of two numbers (rounding towards negative infinity).
     *
     * dividend / divisor
     *
     * examples:
     * integer_division(7, 3) === 2
     * integer_division(7, -3) === -3
     * integer_division(-7, 3) === -3
     * integer_division(-7, -3) === 2
     */
    integer.divide = (dividend, divisor, abort) => {
        if (divisor === 0) {
            abort.divided_by_zero(null);
        }
        const quotient = dividend / divisor;
        // when dividend and divisor have different signs, the quotient is negative
        // For positive quotients, use Math.floor to round down
        // this behavior matches the integer division in Python, Java, and C99 and later
        if (quotient >= 0) {
            return Math.floor(quotient);
        }
        else {
            return Math.ceil(quotient);
        }
    };
})(integer || (exports.integer = integer = {}));
var natural;
(function (natural) {
    let from;
    (function (from) {
        from.dictionary = (dictionary) => {
            return {
                amount_of_entries: () => {
                    return dictionary.__get_number_of_entries();
                }
            };
        };
        from.list = (list) => {
            return {
                amount_of_items: () => {
                    return list.__get_number_of_items();
                },
                reduce: (initial_state, update_state) => {
                    let current_state = initial_state;
                    list.__get_raw_copy().forEach(($) => {
                        current_state = update_state($, current_state);
                    });
                    return current_state;
                }
            };
        };
    })(from = natural.from || (natural.from = {}));
})(natural || (exports.natural = natural = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibnVtYmVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vc3JjL19faW50ZXJuYWxzL3N5bmMvYXNzaWduL2NvbnN0cnVjdC9udW1iZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBR0EsSUFBaUIsT0FBTyxDQW1DdkI7QUFuQ0QsV0FBaUIsT0FBTztJQUVwQjs7Ozs7Ozs7OztPQVVHO0lBQ1UsY0FBTSxHQUFHLENBQ2xCLFFBQWdCLEVBQ2hCLE9BQWUsRUFDZixLQUVDLEVBQ0ssRUFBRTtRQUNSLElBQUksT0FBTyxLQUFLLENBQUMsRUFBRSxDQUFDO1lBQ2hCLEtBQUssQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLENBQUE7UUFDL0IsQ0FBQztRQUNELE1BQU0sUUFBUSxHQUFHLFFBQVEsR0FBRyxPQUFPLENBQUE7UUFDbkMsMkVBQTJFO1FBQzNFLHVEQUF1RDtRQUV2RCxnRkFBZ0Y7UUFFaEYsSUFBSSxRQUFRLElBQUksQ0FBQyxFQUFFLENBQUM7WUFDaEIsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFBO1FBQy9CLENBQUM7YUFBTSxDQUFDO1lBQ0osT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFBO1FBQzlCLENBQUM7SUFDTCxDQUFDLENBQUE7QUFDTCxDQUFDLEVBbkNnQixPQUFPLHVCQUFQLE9BQU8sUUFtQ3ZCO0FBRUQsSUFBaUIsT0FBTyxDQThDdkI7QUE5Q0QsV0FBaUIsT0FBTztJQUVwQixJQUFpQixJQUFJLENBMENwQjtJQTFDRCxXQUFpQixJQUFJO1FBRUosZUFBVSxHQUFHLENBQ3RCLFVBQTZCLEVBQy9CLEVBQUU7WUFDQSxPQUFPO2dCQUVILGlCQUFpQixFQUFFLEdBQ1QsRUFBRTtvQkFDUixPQUFPLFVBQVUsQ0FBQyx1QkFBdUIsRUFBRSxDQUFBO2dCQUMvQyxDQUFDO2FBRUosQ0FBQTtRQUNMLENBQUMsQ0FBQTtRQUVZLFNBQUksR0FBRyxDQUNoQixJQUFpQixFQUNuQixFQUFFO1lBQ0EsT0FBTztnQkFFSCxlQUFlLEVBQUUsR0FDUCxFQUFFO29CQUNSLE9BQU8sSUFBSSxDQUFDLHFCQUFxQixFQUFFLENBQUE7Z0JBQ3ZDLENBQUM7Z0JBRUQsTUFBTSxFQUFFLENBQ0osYUFBcUIsRUFDckIsWUFHVyxFQUNMLEVBQUU7b0JBQ1IsSUFBSSxhQUFhLEdBQUcsYUFBYSxDQUFBO29CQUNqQyxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7d0JBQ2hDLGFBQWEsR0FBRyxZQUFZLENBQUMsQ0FBQyxFQUFFLGFBQWEsQ0FBQyxDQUFBO29CQUNsRCxDQUFDLENBQUMsQ0FBQTtvQkFDRixPQUFPLGFBQWEsQ0FBQTtnQkFDeEIsQ0FBQzthQUVKLENBQUE7UUFDTCxDQUFDLENBQUE7SUFFTCxDQUFDLEVBMUNnQixJQUFJLEdBQUosWUFBSSxLQUFKLFlBQUksUUEwQ3BCO0FBRUwsQ0FBQyxFQTlDZ0IsT0FBTyx1QkFBUCxPQUFPLFFBOEN2QiJ9