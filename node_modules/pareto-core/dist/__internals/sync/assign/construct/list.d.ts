import * as _pi from "../../../../interface";
export declare namespace from {
    const dictionary: <T>(dictionary: _pi.Dictionary<T>) => {
        convert: <New_Type>(assign_item: (value: T, id: string) => New_Type) => _pi.List<New_Type>;
        flatten: <NT>(assign_item: (value: T, id: string) => _pi.List<NT>) => _pi.List<NT>;
    };
    const list: <T>(list: _pi.List<T>) => {
        filter: <New_Type>(assign_optional_item: (item: T) => _pi.Optional_Value<New_Type>) => _pi.List<New_Type>;
        flatten: <NT>(assign_list: ($: T) => _pi.List<NT>) => _pi.List<NT>;
        join: <Other_Type, Result>(other_list: _pi.List<Other_Type>, assign_item: (value: T, other_value: _pi.Optional_Value<Other_Type>) => Result) => _pi.List<Result>;
        map: <New_Type>(assign_item: (item: T) => New_Type) => _pi.List<New_Type>;
        reverse: () => _pi.List<T>;
    };
}
export declare function literal<T>(source: readonly T[]): _pi.List<T>;
export type NonUndefined = null | {};
export declare const nested_literal_old: <T extends NonUndefined | {}>(lists: (undefined | T[] | _pi.List<T>)[]) => _pi.List<T>;
export type Nested<T> = undefined | Nested<T>[] | _pi.List<T>;
export declare const nested_literal_new: <T extends NonUndefined | {}>(nested: Nested<T>) => _pi.List<T>;
export declare const repeat: <T>(item: T, times: number) => _pi.List<T>;
