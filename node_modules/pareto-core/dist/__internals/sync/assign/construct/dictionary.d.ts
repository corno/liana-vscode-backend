import * as _pi from "../../../../interface";
export declare namespace from {
    const dictionary: <T>(dictionary: _pi.Dictionary<T>) => {
        filter: <New_Type>(assign_optional_entry: (value: T, id: string) => _pi.Optional_Value<New_Type>) => _pi.Dictionary<New_Type>;
        flatten: <New_Type>(get_child_dictionary: (value: T) => _pi.Dictionary<New_Type>, abort: {
            duplicate_id: _pi.Abort<string>;
        }) => _pi.Dictionary<New_Type>;
        group: (get_id: (value: T, id: string) => string) => _pi.Dictionary<_pi.Dictionary<T>>;
        join: <Other_Type, Result>(other_dictionary: _pi.Dictionary<Other_Type>, assign_entry: (value: T, other_value: _pi.Optional_Value<Other_Type>, id: string) => Result) => _pi.Dictionary<Result>;
        map: <New_Type>(assign_entry: (value: T, id: string) => New_Type) => _pi.Dictionary<New_Type>;
        re_id: (get_id: ($: T, key: string) => string, abort: {
            duplicate_id: (value: T, id: string) => never;
        }) => _pi.Dictionary<T>;
        resolve: <Resolved>(assign_entry: (value: T, id: string, acyclic_lookup: _pi.lookup.Acyclic<Resolved>, cyclic_lookup: _pi.lookup.Cyclic<Resolved>) => Resolved) => _pi.Dictionary<Resolved>;
    };
    const list: <T>(list: _pi.List<T>) => {
        convert: <NT>(get_id: (item: T) => string, get_value: (item: T) => NT, abort: {
            duplicate_id: _pi.Abort<string>;
        }) => _pi.Dictionary<NT>;
        group: (get_id: (item: T) => string) => _pi.Dictionary<_pi.List<T>>;
    };
}
export declare function literal<T>(source: {
    readonly [id: string]: T;
}): _pi.Dictionary<T>;
