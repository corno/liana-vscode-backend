import * as _pi from "../../../interface";
export type Option<T> = readonly [string, T];
/**
 * ss means 'switch state'.
 * used to make the value T the context variable ('$')
 * given a tuple of a string and a value T,
 * the function takes the value T and calls back the callback ($c)
 * notice that the string part is never used
 *
 * example:
 *
 * switch ($.state[0]) {
 *     case 'on':
 *          return ss($.state, ($) => $.value)
 *     case 'off':
 *          return ss($.state, ($) => null)
 *     default: return au($.state[0])
 * }
 */
export declare function ss<T, RT>(option: Option<T>, $c: ($: T) => RT): RT;
/**
 * au means 'assert unreachable'. Used in the 'default' clause of switch statements to ensure
 * during compile time that all possible cases have been implemented
 *
 * example:
 *
 * switch (x) {
 *     case '5':
 *         return 5
 *     default: return au(x)
 * }
 *
 * @param _x
 */
export declare function au<RT>(_x: never): RT;
export declare namespace decide {
    const boolean: <RT>(boolean_value: boolean, if_true: () => RT, if_false: () => RT) => RT;
    const dictionary: <T>(dictionary: _pi.Dictionary<T>) => {
        has_entries: <RT>(if_true: ($: _pi.Dictionary<T>) => RT, if_not_true: () => RT) => RT;
        has_single_entry: <RT>(if_true: ($: T, id: string) => RT, if_multiple: ($: _pi.Dictionary<T>) => RT, if_none: () => RT) => RT;
    };
    const list: <T>(list: _pi.List<T>) => {
        has_first_item: <RT>(if_true: ($: T, rest: _pi.List<T>) => RT, if_not_true: () => RT) => RT;
        has_items: <RT>(if_true: ($: _pi.List<T>) => RT, if_not_true: () => RT) => RT;
        has_last_item: <RT>(if_true: ($: T, rest: _pi.List<T>) => RT, if_not_true: () => RT) => RT;
        has_match: <RT>(test: ($: T) => _pi.Optional_Value<RT>, if_no_match: () => RT) => RT;
        has_single_item: <RT>(if_true: ($: T) => RT, if_multiple: ($: _pi.List<T>) => RT, if_none: () => RT) => RT;
    };
    const optional: <T, RT>(optional: _pi.Optional_Value<T>, if_set: ($: T) => RT, if_not_set: () => RT) => RT;
    const state: <T extends readonly [string, any], RT>(state: T, assign: (output: T) => RT) => RT;
    const text: <RT>(text: string, assign: (output: string) => RT) => RT;
}
